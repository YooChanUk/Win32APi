[SAL]
SAL은 주석이라서 실제로는 무시되는것이며 해당 변수의 용도를 함축된 의미로 키워드로 바꿔서 의미하는것
_In_ 들어오는것 _In_opt_ 들어오지만 옵션적인것

이전에는 hPrevInstance가 쓸모가 있었지만 가상 메모리 환경으로 들어오며 의미가 없어진 상태가 되었다.
정확히 의미가 없는건 아니겠지만 같은 프로그램을 실행하면 주소가 똑같이 나와서 가상 메모리에서 부터 주소를 0부터 시작한다고 생각하면
hPrevInstance의 쓸모는 예전에 사라진것과 같다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
wWinMain에 파라미터로 들어오는 hInstance 타입으로 들어오는 값은 프로세스가 시작되는 메모리의 주소이다.
IpCmdLine은 문자열로 명령어를 불러올 수 있는 문자열 버퍼 칸이라고 생각하면 된다. 받아온 문자열이 무엇인지에 따라
분기 처리하여 알맞게 실행한다.

LPWSTR은 wchar_t* 다

LoadStringW는 캡션값에 알맞은 문자열을 string table에서 가져오라고하는 윈도우 제공 함수
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[GetMessage함수]
메세지큐에서 메세지 확인할때까지 대기
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[커널윈도우]
창을 생성해내면 이 창은 메모리 어딘가에 저장이 되서 관리할 수 있을텐데 이 창은 OS단에서 관리하기에 우리가 관리할수없다. 
그러나 그것을 제어할수있게끔 ID를 제공해주는데 이것을 윈도우 핸들이라 한다.
ShowWindow 함수도 그렇다.
HDC는 device context단에서 관리하는 커널 윈도우다. 그렇기에 이것도 ID를 넘겨준다.
고로 ID = 핸들값
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[핸들값 마다 구조체로 따로 관리하는 이유]
핸들값 안에는 결국 int a 같은 하나의 ID값만 존재한다. 이것을 id라고 하는 하나의 구조체안에 모두 통틀어서 관리하지 않는 이유는
ID값마다 고유의 자료형을 가지게되어 서로서로가 비교 되게끔 할 수 있게 만들어 놓은 이유이다.

함수에서 일반 int값을 요구하는것과 ID자료형을 가진것을 요구하는것 둘 중 무엇이 더 오류를 제어하기 손 쉬울지 고민해보면 된다.
int값은 int라면 뭐든지 다 들어올 수 있지만 ID자료형에 경우는 그 자료형에 맞는것만 끼워 맞출 수 있기 떄문이다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[HDC]
윈도우에 무언가를 그리기 위한 그림도구들의 집합체 펜,브러쉬,종이 도구 등등
그리기작업에 필요한 DATA집합
DC의 목적지는 hWnd
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[RGB]
RGB는 비트를 합치는것으로 색을 구분할 수 있게 만들었다. 8비트만큼 밀면 R의 왼쪽으로 16비트만큼 밀면 GR의 왼쪽으로 이동하여 완성된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[SelectObject함수]
는 보이드포인터로 되어있다. 이유는 굉장히 범용적인 함수로 이용하기 위함이다.
HPEN말고도 HBRUSH 자료형도 가져가고 반환 할 수 있기 때문에 캐스팅하여 사용하기 위해 지정해놓은것이다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[GetStockObject]
GetStockObject();//자주쓰는 펜과 자주쓰는 브러쉬는 이미 저장되있다. 그렇기에 이것은 다시 원래의 브러쉬로 되돌릴지 언정
삭제를 해서는 안된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[WM_KEYDOWN]
케이스는 키가 입력되었을때 감지해주는 기능이다. 그러나 어떤 키가 입력되었는지 확인할 수 있게 해주는 인자값은 
wParam(키), lParam(마우스)
윈도우에서는 각 키에대한 고유한 ID값을 define으로 정해놨다. 화살표는 VK_UP 영문키값은 문자의 아스키 코드(대문자 기준) 키값으로 들어온다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[키를 눌렀을때 오브젝트가 움직이게 하는것은 화면을 새로고침하는것]
WM_PAINT가 다시 동작해야하는데 오브젝트가 움직인것만 행했기에 화면을 다시 껐다켰을때에 새로운 화면이 나오는 이유는 여기에있다.
그렇기에 무효화 영역을 우리가 다시 직접 호출함으로써 새로고침을 할 수 있다.
InvalidateRect(윈도우 ID,화면위치(nullptr은전체),berase(화면 새로고침));

물체의 영역을 내가 맘대로 옮긴것이기때문에 이것이 움직였다는것을 보고 할 필요가 없다. 그렇기 떄문에 우리가 원하는대로라면 다시 그려줘야 하기 때문에
이것을 우리가 직접적으로 호출하여 바뀌었음을 알린것
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[프레임에 대한 이야기]
우리가 보는 화면은 이미 완성된 화면을 보는것이다. 도화지가 하나인경우 사람의 눈으로 그려지는 상황을 볼 수 있는 타이밍이 존재 할 것이다.
이것을 해결하기 위해서는 그려지는 화면을 뒤로 넘겨서 완성된뒤에 보여주고 나머지는 바뀐부분만 선택하여 새로고침 할 수 있으면 될 것이다.

그 외로 우리는 우리가 설정한것에 대해서만 새로고침을 시도했지 AI가 움직이거나 내가 설정하지 않은것이 움직이는것을 표현하기 위해서는
그들의 움직임을 새로고침 해주기 위해 타이머를 생성해줄 수 있다. 이 타이머는 지정해놓은 시간동안 WM_TIMER라는 메세지를 발생 시킨다.
타이머 또한 커널 오브젝트 이기 떄문에 우리가 제거를 해줘야 한다.
killTimer
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[PeekMessage]
겟메세지와 다르게 큐에있는 메시지를 계속 대기하지 않고 peek(보다) 보는것처럼 있는지 없는지를 계속 확인하여 없으면 없다고 반환해주고 있으면 있다고 반환해준다.
그렇기에 peek메세지는 항상 반환되는 함수이다(메세지 유무와 관계없이 반환)

    while (true)
    {
        if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
        {
            if (WM_QUIT == msg.message)
            {
                break;
            }

            if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

이렇게만 놔두면 getMessage와 별다를게 없다. 결국은 메세지를 받았을때는 수행하는게 똑같지만
픽메세지는 메세지가 없는 경우에 else를 붙여서 그외의 일을 수행할 수 있다. 결국은 계속해서 일을 할 수 있게 만들 수 있다

이 경우는 비동기 방식 체크라서 창을 내려도 메세지 체크를 해버린다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[싱글톤]
객체의 생성을 1개로 제한하고 언제 어디서든 쉽게 접근이 가능한 코어 시스템을 위해서는 extern이 사용될수 있지만 extern이 사용된다는건
어디서든 새롭게 객체의 생성을 또 할수도 있다는것이기에 이것을 방지하기위해 생성자를 private으로 숨겨버리는것이다.
객체 생성할때에는 생성자가 반드시 호출되어야하는데 private으로 설정시 생성자를 다른곳에서 부를 수 없고 자기 파일내에서 본인만 호출이 가능하기 때문이다.
대신 이 경우는 extern선언도 안된다.

대신 public내에서 자신의 생성자를 호출 할 수 있는 함수를 제공하여 그것을 반환하게끔 해준다.
그러나 클래스의 함수는 객체를 생성해야만 쓸 수 있는 구조로 되있기에 함수를 호출 할수가 없다.
그러나 객체가 없어도 되는 함수는 호출 할 수 있다.

static키워드가 붙은 멤버함수는 객체없이 자료형만으로도 호출이 가능하다.
그러나 정적(static)멤버 함수는 일반적인 멤버함수처럼 this 즉 객체를 생성 시킨뒤에 자신의 멤버변수들이 어떤 객체의 멤버변수인지를 알 수가 없다.
멤버변수의 소환 없이 자기 혼자만 호출되었기 떄문이다. 애초에 객체없이 호출이 가능한건 누가 호출했는지 알 필요가 없다 즉 this를 알 필요없다 인 것이다.

또한 객체를 생성해서 호출한다해도 this가 전달 될 수 있는 구조가 아니다.
그러나 접근 가능한 멤버가 있는데 똑같은 정적인경우에 접근이 가능하다

정적멤버와 정적함수는 클래스 내부에서만 접근이 가능하고 그 클래스 내부에 하나만 존재하고 클래스 내부에서끼리 static으로 접근이 가능하기 때문에
하나만 생성된것과 다름이 없다. 클래스를 어디에 선언해도 static은 무조건 하나만 존재하기 때문에 구조상으로 하나만 존재하게 만들어진 것이다.

★또한 클래스내부에 선언된 정적멤버는 클래스 밖에서 초기화를 무조건 해줘야한다.(데이터에 올라갈것이기 때문에)

	static void Release()
	{
		CCore* p = GetInstance();
		delete p;
	}

코어라는 객체를 하나만 만들어서 동적으로 할당해 힙에 할당하였을경우에는 우리가 직접 delete를 시켜줘야한다.
그렇기에 core의 주소를 그대로 반환하는 getinstance를 그대로 받으면 그 주소를 그대로 들고오기 때문에 그대로 delete를 시키면 되지만

만약 내가 다시 getinstance를 받아야된다면, static으로 완성된 코어변수는 삭제된 주소를 그대로 들고 있는것이기 때문에 다른 방안이 필요하다.
지역변수내에서만 코어 변수를 만들게 아니라 이것을 클래스 전체 내에서 쓸 수 있게 만들어주면 해결되는 문제이다.

	static CCore* GetInst()
	{
		static CCore core;

		return &core;
	}

위의 경우는 데이터 영역에 바로 올린 경우이다. 이 경우에는 내가 릴리즈를 신경 쓸 필요는 없지만
내가 원하는 경우에 해제가 불가능하다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[미리 컴파일된 헤더]
프로젝트내에 속성에서 미리컴파일된헤더에서 만들기로 표시해두면 그 아래에 있는 이름대로 헤더파일을 만들어놓고 그 헤더파일은 모든 파일에 들어가야만하는
규칙이 생긴다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[getDC]
beginPaint는 무효화 영역이 감지되는 순간 그리는것을 시작하고 EndPaint로 그리기가 끝났음을 알리는 유기적 연결구조로 되있기에 함부로 이용할 수 없다.
우리는 그림을 그리고만 싶을뿐이기에 getDC를 사용하면되고 getDC는 커널 오브젝트이기 때문에 클래스가 끝날때 ReleaseDC를 해주면 된다.

GetDC는 m_hWnd(메인핸들)의 DC(디바이스 컨텍스트)의 핸들을 반환한다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[더블 버퍼링]
우리 눈에는 그려지고 있는 과정은 보여주면 안된다. 우리는 다 그려진 상황을 봐야하기에 다른 비트맵을 하나 더 그려 그곳에서 그린 뒤
원래의 비트맵으로 가져오면 될 것이다. 

	m_hBit = CreateCompatibleBitmap(m_hDC, m_ptResolution.x, m_ptResolution.y);
	m_memDC = CreateCompatibleDC(m_hDC);

	HBITMAP hOldBit = (HBITMAP)SelectObject(m_memDC, m_hBit);
	DeleteObject(hOldBit);

크리에이트컴페티블은 호환에맞는것을 주는 함수이다. m_hDC DC의핸들을 건네주면 그 DC와 연결된 디바이스의 비트맵을 넘겨주는데
해상도를 같이 넘겨준뒤
밑의 컴페티블은 DC의 핸들을 하나 더 만드는것이다.
그 뒤 SelectObject(보이드 이기에 캐스팅)로 m_memDC와 m_hBit를 합치면 그릴곳이 정해지게 되는데 이때 반환되는것은 DC를 생성시킬때 주는
하나의 점 비트맵을 반환하게 된다.
그렇기에 쓸 일이 없기에 Delete한다.

또한 create로 만들어준 비트맵과 DC는 Delete로 지워줘야 한다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[키매니저가 필요한 이유]
우리의 프로그램은 한 DT 1프레임 안에서 모든 일들이 일어나기 때문에 스탑모션으로 우리가 하나하나 지정해주는것들을 사용자는 눈치채지 못할 수 밖에 없다.
그러나 우리가 프로그램을 짜면서 윗코드에 왼쪽 키가 눌렸는지 확인하여 시행되는 일과 그 맨 아래에 왼쪽키가 눌렸는지 한번 더 확인하여 시행되는 일에는 DT라는 아무리 짧은 시간이여도 둘 사이에 왼쪽을 눌렀는데 안 눌리는 경우가 발생해서 일어나는  오류가 생길 수 있다.

이것을 해결하기 위한 동기화를 해주기 위해 키 매니저는 필요하다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[화면을 내리면 키가 입력이 안되게끔 한다.]
대신 이 상황에서는 HOLD를 하고 있는 도중 화면이 내려간 상황에 대해서 대처가 필요하다. TAP도 마찬가지
HOLD를 하고 있는데에 예외처리가 없을경우 다음에 다시 화면으로 돌아왔을때 키가 더 이상 먹지 않는 경우가 있을 수 있기 때문에
그 경우를 위해 HOLD->AWAY-NONE의 플로우를 어느 떄에든 그릴 수 있게 만들어 놔야 한다.

메인 윈도우가 무조건 올라와야지 키매니저가 동작할거라면 포커싱 되있는 윈도우 핸들값과 지금 보고 있는게 같다면 으로 체크하고
현재 포커싱된 윈도우가 다른 윈도우여도 동작하게 하고 싶다면 포커싱윈도우가 널인지 아닌지만 체크하면 된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[델타타임 Deltatime]
우리의 컴퓨터는 프레임이 존재하는데 이 프레임은 컴퓨터의 성능에따라 높아지거나 낮아지기도한다.
프로그램은 프레임단위로 움직이는 오브젝트들이 있는데 이 오브젝트들이 프레임에 따라 속도가 높아지거나 낮아지거나 하는게 아니라
초단위로 움직여야지 사람에게 보이는게 다들 일정하게 움직이는것처럼 보일 것이다.

이것을 계산하기 위해서는 이동속도 x 프레임 분의 1초 이 계산식으로 한 프레임당 이동속도를 얼마나 줘야하는지를 계산해야하는데
이 1프레임당의 시간을 DeltaTime이라고 부른다.

이것을 계산하기 위한 GetTickCount는 1초당 1000을 셀 수 있는데 우리의 컴퓨터는 이것보다 훨 씬 빠른속도로 동작하기 때문에
1000보다 훨 씬 더큰 숫자의 틱을 셀 수 있어야한다.
초당 세는 단위가 백만인 QueryPerformenceCounter 함수가 있다.

[정적변수] - 파일(함수)전용 정적변수
이로인해 모든 파일이 합쳐지기 전에 같은 이름의 변수(전역변수)가 존재하면 컴파일 에러가뜨지만
static 정적 변수로 이곳저곳에 선언할시에는 그 파일안에 하나의 존재만 존재하게된다.(메모리영역에 존재하는 cpp파일안에 하나의 이름을 가진 유일무이한 존재) 그렇기에 다른 파일에서 전역변수로 선언된 이름과 동일시 되지않음(메모리 영역이 다르게 되있으며 고정되어있기에(바뀌지 않기에))

static은 무조건 데이터 영역에 들어간다. 그렇기에 스택 함수 영역에 들어가있어도 함수가 호출되거나 종료될때 사라지거나 하지 않고 프로그램이 종료되기까지 자신의 데이터를 유지한다.
지역변수에 있을때는 그 지역변수안에서만 유지되며 전역변수인경우 그 파일안에서만 유지된다.

누군가 전역변수를 쓸수도있지만 내가 스태틱 변수로 함수안에 설정할시 그 안에서만 횟수를 바꾸거나 할수있기에
기능제한으로 인해 조금 더 폐쇄적으로 변수 사용을 유도할수있다.(써야하는곳에만 쓰게끔)

클래스내에도 선언 될 수 있지만
static은 데이터영역에 저장될때 한번만 호출되고 끝난다.(최초 초기화 이후 건너뜀)
대신에 클래스 내부에서만 접근이 가능하다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[씬 Scene]
씬에는 오브젝트들의 집합체로 이루어져있는데 이 씬은 인게임 또는 캐릭터 선택화면 메인메뉴 등은 여러가지 오브젝트들이 각종으로 있는 씬들이 여러개 있을것이다.

이 씬마다 오브젝트들을 배치 할 수 있게 오브젝트를 각각 나누고 가져올것만 가져와서 씬에 이름을 붙여서 사용하는게 효율적이다.

씬에는 Start라는 자신을 구동시키는 함수가 필요하다. 모든 씬에 필요하기때문에 씬을 집합으로 관리하는 부모 파일내에 Start함수를 하면 된다고 생각하겠지만 정작 부모는 Start를 사용 할 일은 없다.
그렇기 때문에 선언은 하되 부모에서는 사용하지 않게 interface형식으로 자식들은 이것을 모두 구현해라 라는 의미로
순수 가상함수를 만들면된다. 이점으로는 Start를 실수로라도 구현하지 않으면 나머지 자식 씬들이 모두 객체화 될 수 없게 할 수 있다.(예외처리 바로 가능)

virtual 키워드가 없었어도 부모쪽에서 오버로딩되어 내려온 함수는 virtual가 암시적으로 붙어있다. 그러므로 개발자 입장에서 알기 쉽게
virtual를 그냥 붙여주는게 보기 편하다.(문제는 아니지만 붙여주면 좋다)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[순수 가상함수]
virtual 가상함수와 다르게 순수 가상함수는 클래스내부의 함수를 자체적으로 인터페이스 형식으로 만든다
이 뜻은 앞으로 이 클래스를 부모로 사용하는 자식들은 업데이트 구문을 만들어야 하지만 부모 자체는 업데이트 클래스를 만들어라! 라고 명시해놓은 셈이 된다.

virtual void Start() = 0; //순수 가상함수 해당 씬 진입시 호출
virtual void Exit() = 0;// 해당 씬 탈출 시 호출

위와 같이 함수에 = 0 을 붙이면 된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[알아두면 좋은 수학]
삼각함수,호도법(라디안)원주율,벡터,스칼라,내적,외적,공간도형,물리1(힘파트 거/속/시),가속도,등가속도,마찰력
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[기초수학]
라디안 = 원주율 파이를 통해 계산할 수 있다.

원을 정의하자면 원의 중심에서 원의 둘레에 도달하는 거리를 우리는 반지름이라 부른다.(약자로 라디우스 r)
원의 지름과 전체둘레 길이의 비율이 있다.

지름과 둘레의 길이 간의 비율(원주율)
지름(2r)과 3.14(파이)를 곱하면 원의 둘레의 길이가 나오더라
그렇다면 반지름 입장에서(r)과 파이만을 곱하면 둘레의 절반이 나올것이다.

반지름과 원의 둘레 비율값에 대한 이야기가 호도법의 라디안을 의미한다. 파이단위는 라디안으로 해석되는데
3.14라디안 이라고하면 180도를 의미하는 값이 나온다.

그렇다면 1라디안은? 57도정도의 각도이다.
라디안은 반지름과 호의 길이의 비율값이다.
그럼 1라디안은 반지름과 곲했을때 둘레의 길이에서 1라디안 즉 r만큼만의 둘레를 의미한다.

삼각함수하면 생각나는건 비율 cos sin tan 일것이다. 이와 관련된건 직각삼각형과 관련이 깊은데
빗변이 1일때 세타가 마주보는 변이 높이 그리고 그 밑은 밑변이다.
 cos세타 는 빗변분의 밑변
 sin세타 는 빗변분의 높이
 tan세타 는 밑변분의 높이
보통 기울기 값은 tan세타 이다.

피타고라스의 정리 a제곱 더하기 b제곱은 c제곱

[벡터와 스칼라]
스칼라는 순수한 값(크기) 벡터(크기,방향성 정보)

벡터에서 x가 1 y가 1일때 빗변을 똑같이 1만큼 가게 하기위해 곱하는 값을 벡터의 노말라이즈(정규화)라고 한다.
정규화 공식은 본인의 길이값으로 나누어준다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[리소스]
텍스처던 사운드던 가져줘야하는 공통 값은 키값, 상대경로

텍스처의 경우(이미지)는 오브젝트마다 따로 오브젝트 형식으로 텍스처를 관리할게 아니라 텍스처 이미지를 비트맵에 도장처럼 꽝꽝 찍으면 되는 느낌이기 때문에
우리가 필요한건 그 이미지를 그려줄 비트맵과 디바이스 컨텍스트다. 왜냐하면 그려주는 도구가 저것이기 때문

빌드한 파일 장소를 우리가 알아서 바꾸거나 이름을 정해줄 수 있다.
프로젝트에서 우클릭하여 속성 부분 일반에서 출력 디렉터리의 내용을 바꾸면 된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[GetObject]
가로 세로 길이를 알기위한 오브젝트의 내용을 불러 올 수 있는 함수 메인핸들로는 비트맵을 넣어주면된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
UINT상태에있는 width와 height는 다시 비트맵 좌표로 넘길때는 int상태로 바꾸어줘야한다. 우리는 좌표상에 그릴 예정이기에 좌표에는 음수가 존재하여
캐스팅 해주지 않으면 에러가 생긴다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[TransparentBlt]
BMP파일에 보면 보라색으로 되있는 픽셀들이 존재한다 255  0 255로 되있는데 이 RGB값이 잘 안쓰이기때문에 게임에 들어가서 무시하기 위해 존재하는 값이다.
transparentBlt를 쓰면 그 픽셀값을 무시할 수 있게된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[콜라이더 컴포넌트]
충돌이 필요한 경우와 충돌이 필요하지 않은 오브젝트들을 묶어서 상속으로 관리하던 클래스로 관리하던 확장성에 문제가 생기기 마련이다.
필요하지 않던 오브젝트가 갑자기 필요해지는 순간이 오면 대공사를 해야할수도있다.
그렇기 때문에 컴포넌트라는 방식을 채택하여 컴포넌트에 필요한 내용을 적고 그게 필요하면 필요한 애들만 동적할당 방식으로 생성시켜서
그것을 껐다 켰다 할 수 있게 만드는 방식이다.

오브젝트가 그렇게 콜라이더를 생성하여서 오브젝트가 안다고해도 콜라이더도 똑같이 오브젝트를 따라 다녀야 하기때문에 서로가 서로의 위치를 알고 있어야한다.

또한 충돌방식은 DT 타임 프레임에 따라서 충돌이 일어나기 때문에 프레임에 따라 충돌이 여러번 일어나서 데미지가 누적되는 현상을 방지하기위해 
ENTER EXIT 함수를 이용해 한번만 동작하게끔 해야한다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	virtual void finalupdate() final;
부모는 함수를 실행할 이유가 없기때문에 순수 가상함수를 만들 수 있다. 그러나 오로지 부모에서만 사용 될 것만 같은 함수라면 자식쪽에서는 더 이상
재정의가 불가능하게끔 가상함수 뒤에 final을 붙여 생성한다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
memset()
내가 지정한 변수를 바이트단위로 세팅하는것
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
복사생성자를 쓰는 경우(개별적으로 만들지 않아도 덮어 씌우는식으로 복사되어 생성된다)그러나 이 경우
ID값이 존재한다면 똑같은 id값을 가진 객체가 하나 더 생성되는것이기때문에 이를 방지하기 위해서 깊은복사를 시행해야한다.

또한 디폴트 대입연산자로도 똑같이 id값을 다시 가져갈수있기 때문에 이것도 조정해야한다. 하지만 콜라이더를 가지고와서 이것을 대입하여 새로 만드는것 자체는
보통 일어나지 않을법한 일이기때문에 대입 자체를 방어하는게 나을것이다.

CCollider& operator = (CCollider& _origin) = delete; 만들자마자 삭제되게 만드는것이다. 복사하여 새로 대입생성 되기전에 삭제 시킨다고 생각하면된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[EventMgr]
Delete 삭제할때 이벤트 매니저에서는 다음 프레임에서 바로 삭제될경우 참조하던 녀석들 즉 이전 프레임에
키가 눌렸으면 이번 프레임엔 이런 일을 수행해야한다 라고 지정해놓은 애들이 참조를 하다가 null이 되어 크러쉬가 날 수있기 떄문에
이제 삭제할 예정이다 라고 플래그를 미리 띄워주는것으로 1프레임을 더 지연시켜줘야한다.

이것을 이용하기위해서는 evenMgr은 삭제할 예정인 이벤트를 따로 보관하여야한다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
//템플릿 내에서 이너클래스를 쓰려면 typename을 앞에 붙일것
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[GetCursorPos]
마우스의 위치를 Vec로 찍어오는 함수인데, 이 마우스의 위치는 우리 윈도우 전체 화면을 기준으로 하기때문에 전체화면에서 윈도우까지의 좌상단 면적을 빼서
게임창 좌상단을 잡아내야한다. 이것을 위해  우리는
ScreenToClient함수를 사용한다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[유니티빌드]
사람이 보기 편하게 파일을 여러개로 나누어 cpp와 헤더파일이 많아지면 IDE입장에서는 하나하나 일일이 까서 확인해야하는 수고스러움이 있다
결국은 한파일에 합쳐서 컴파일을 해버릴것이기 때문에 수고스럽게 그럴 필요없이 한 파일을 만들어내어 그곳에 include로 몰아 넣는것을 말한다.
이것을 비쥬얼 스튜디오에서 지원하여
유니티 빌드라는 이름으로 지원한다.

프로젝트에 속성 고급 고급속성 유니티빌드 예
c/c++ 일반에 다중 프로세서 컴파일을 예
c/c++ 미리 컴파일된 헤더 사용안함
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[C++ 다이어로그에 입력한 값 불러오는 함수]
GetDlgItemInt(hDlg,IDC_EDIT1,nullptr,false)
다이어로그 핸들,받아올 정수값을 가진 윈도우 ID,모름,int로할지 UINT로 할지
값은 텍스트(문자열)로 구성되있지만 GetDlgItemInt 함수 이름과 같이 정수형으로 바꿔서 가져온다.
고로 다른 자료형을 가질 수 있게 함수를 바꿀수도 있다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
멤버함수(윈도우 멤버함수)는 우리가 만든 파일중 어느 헤더에도 구현된게 아닌 윈도우에 귀속된 헤더이다.
그렇기때문에 우리의 전역함수를 불러오고 싶어도 이 멤버함수는 객체가 없기 때문에 불러 올 수 없는 구조로 되어있다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[복사생성자]
부모를 가진 복사생성자의 경우 복사생성시 내가 따로 명시 해놓지 않으면 부모의 기본복사생성자를 호출한다. 그렇기 떄문에
모두 정확하게 복사해오고 싶으면 내가 직접 부모의 복사생성자까지 호출할것이다를 명시해줘야한다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
typedef void(*BTN_FUNC) (DWORD_PTR, DWORD_PTR);
위 형태와 같은 함수만 받을수있도록 함수포인터를 타입으로 지정가능
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
//szName은 절대경로를 붙여서 경로를 전달하기에 다른곳에서도 사용하는 LoadTile은
//상대경로를 사용하게끔 놔두는게 좋다. 그렇기에 szName에서 절대경로 부분은 자르고
//상대경로만 넘기는게 좋다.
//
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[버튼 함수포인터]
다른곳에있는 함수들을 쓰기 위해서는 가장큰 부모를 만들어 거기서 파생되어 만드는게 처음부터 만드는 상황을 만들때 가장 좋은 방법이다.
그러나 지금 win32api공부할때 그렇게 쓰지 않았기때문에 
typedef void(CScene::*SCENE_MEMFUNC)(void);
typedef void(CObject::* OBJECT_MEMFUNC)(void);
가장 큰 원형들만 헤더에 불러온뒤

    void SetClickedCallBack(CScene* _pScene, SCENE_MEMFUNC _pSceneFunc)
    {
        m_pSceneInst = _pScene;
        m_pSceneFunc = _pSceneFunc;     
    }

써야하는 객체를 불러오고 그 함수를 둘다 포인터 형식으로 데려와서 버튼을 눌렀을때 무엇을 하게 될지 설정해주면된다.

void CBtnUI::MouseLbtnClicked()
{
	if (nullptr != m_pFunc)
	{
		m_pFunc(m_param1,m_param2);
	}

	if (m_pSceneInst && m_pSceneFunc)
	{
		(m_pSceneInst->*m_pSceneFunc)();
	}
}

방식은 이런식이다. ((*m_pSceneInst).*m_pSceneFunc)(); 포인터형식이기에 원형으로 불러온뒤 우리가 쓸 함수도 포인터이기에 원형으로 불러온다.

또한 전역함수는 함수포인터에 전달할때 & 를 안붙여도 주소로 인식해주는데
사실은 & 이것을 붙여주는게 맞다

((CBtnUI*)pBtnUI)->SetClickedCallBack(this, (SCENE_MEMFUNC)&CScene_Tool::SaveTileData);

다른곳에서 불러와서 쓸때는 이렇게 쓰면된다. 또한 우리가 지정해주었던 자료형으로 캐스팅해주면 씬 함수들을 모두 가져올수있다.
또한 멤버함수포인터를 선언할때는 정확한 클래스의 정보를 알아야한다.
고로 전방선언같이 인터페이스로 이것이 존재한다! 라는 통속의 뇌 보다는
아예 include하여 이것이다 라고 알려줘야한다.