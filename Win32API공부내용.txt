[SAL]
SAL은 주석이라서 실제로는 무시되는것이며 해당 변수의 용도를 함축된 의미로 키워드로 바꿔서 의미하는것
_In_ 들어오는것 _In_opt_ 들어오지만 옵션적인것

이전에는 hPrevInstance가 쓸모가 있었지만 가상 메모리 환경으로 들어오며 의미가 없어진 상태가 되었다.
정확히 의미가 없는건 아니겠지만 같은 프로그램을 실행하면 주소가 똑같이 나와서 가상 메모리에서 부터 주소를 0부터 시작한다고 생각하면
hPrevInstance의 쓸모는 예전에 사라진것과 같다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
wWinMain에 파라미터로 들어오는 hInstance 타입으로 들어오는 값은 프로세스가 시작되는 메모리의 주소이다.
IpCmdLine은 문자열로 명령어를 불러올 수 있는 문자열 버퍼 칸이라고 생각하면 된다. 받아온 문자열이 무엇인지에 따라
분기 처리하여 알맞게 실행한다.

LPWSTR은 wchar_t* 다

LoadStringW는 캡션값에 알맞은 문자열을 string table에서 가져오라고하는 윈도우 제공 함수
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[GetMessage함수]
메세지큐에서 메세지 확인할때까지 대기
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[커널윈도우]
창을 생성해내면 이 창은 메모리 어딘가에 저장이 되서 관리할 수 있을텐데 이 창은 OS단에서 관리하기에 우리가 관리할수없다. 
그러나 그것을 제어할수있게끔 ID를 제공해주는데 이것을 윈도우 핸들이라 한다.
ShowWindow 함수도 그렇다.
HDC는 device context단에서 관리하는 커널 윈도우다. 그렇기에 이것도 ID를 넘겨준다.
고로 ID = 핸들값
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[핸들값 마다 구조체로 따로 관리하는 이유]
핸들값 안에는 결국 int a 같은 하나의 ID값만 존재한다. 이것을 id라고 하는 하나의 구조체안에 모두 통틀어서 관리하지 않는 이유는
ID값마다 고유의 자료형을 가지게되어 서로서로가 비교 되게끔 할 수 있게 만들어 놓은 이유이다.

함수에서 일반 int값을 요구하는것과 ID자료형을 가진것을 요구하는것 둘 중 무엇이 더 오류를 제어하기 손 쉬울지 고민해보면 된다.
int값은 int라면 뭐든지 다 들어올 수 있지만 ID자료형에 경우는 그 자료형에 맞는것만 끼워 맞출 수 있기 떄문이다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[HDC]
윈도우에 무언가를 그리기 위한 그림도구들의 집합체 펜,브러쉬,종이 도구 등등
그리기작업에 필요한 DATA집합
DC의 목적지는 hWnd
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[RGB]
RGB는 비트를 합치는것으로 색을 구분할 수 있게 만들었다. 8비트만큼 밀면 R의 왼쪽으로 16비트만큼 밀면 GR의 왼쪽으로 이동하여 완성된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[SelectObject함수]
는 보이드포인터로 되어있다. 이유는 굉장히 범용적인 함수로 이용하기 위함이다.
HPEN말고도 HBRUSH 자료형도 가져가고 반환 할 수 있기 때문에 캐스팅하여 사용하기 위해 지정해놓은것이다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[GetStockObject]
GetStockObject();//자주쓰는 펜과 자주쓰는 브러쉬는 이미 저장되있다. 그렇기에 이것은 다시 원래의 브러쉬로 되돌릴지 언정
삭제를 해서는 안된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[WM_KEYDOWN]
케이스는 키가 입력되었을때 감지해주는 기능이다. 그러나 어떤 키가 입력되었는지 확인할 수 있게 해주는 인자값은 
wParam(키), lParam(마우스)
윈도우에서는 각 키에대한 고유한 ID값을 define으로 정해놨다. 화살표는 VK_UP 영문키값은 문자의 아스키 코드(대문자 기준) 키값으로 들어온다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[키를 눌렀을때 오브젝트가 움직이게 하는것은 화면을 새로고침하는것]
WM_PAINT가 다시 동작해야하는데 오브젝트가 움직인것만 행했기에 화면을 다시 껐다켰을때에 새로운 화면이 나오는 이유는 여기에있다.
그렇기에 무효화 영역을 우리가 다시 직접 호출함으로써 새로고침을 할 수 있다.
InvalidateRect(윈도우 ID,화면위치(nullptr은전체),berase(화면 새로고침));

물체의 영역을 내가 맘대로 옮긴것이기때문에 이것이 움직였다는것을 보고 할 필요가 없다. 그렇기 떄문에 우리가 원하는대로라면 다시 그려줘야 하기 때문에
이것을 우리가 직접적으로 호출하여 바뀌었음을 알린것
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[프레임에 대한 이야기]
우리가 보는 화면은 이미 완성된 화면을 보는것이다. 도화지가 하나인경우 사람의 눈으로 그려지는 상황을 볼 수 있는 타이밍이 존재 할 것이다.
이것을 해결하기 위해서는 그려지는 화면을 뒤로 넘겨서 완성된뒤에 보여주고 나머지는 바뀐부분만 선택하여 새로고침 할 수 있으면 될 것이다.

그 외로 우리는 우리가 설정한것에 대해서만 새로고침을 시도했지 AI가 움직이거나 내가 설정하지 않은것이 움직이는것을 표현하기 위해서는
그들의 움직임을 새로고침 해주기 위해 타이머를 생성해줄 수 있다. 이 타이머는 지정해놓은 시간동안 WM_TIMER라는 메세지를 발생 시킨다.
타이머 또한 커널 오브젝트 이기 떄문에 우리가 제거를 해줘야 한다.
killTimer
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[PeekMessage]
겟메세지와 다르게 큐에있는 메시지를 계속 대기하지 않고 peek(보다) 보는것처럼 있는지 없는지를 계속 확인하여 없으면 없다고 반환해주고 있으면 있다고 반환해준다.
그렇기에 peek메세지는 항상 반환되는 함수이다(메세지 유무와 관계없이 반환)

    while (true)
    {
        if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
        {
            if (WM_QUIT == msg.message)
            {
                break;
            }

            if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

이렇게만 놔두면 getMessage와 별다를게 없다. 결국은 메세지를 받았을때는 수행하는게 똑같지만
픽메세지는 메세지가 없는 경우에 else를 붙여서 그외의 일을 수행할 수 있다. 결국은 계속해서 일을 할 수 있게 만들 수 있다

이 경우는 비동기 방식 체크라서 창을 내려도 메세지 체크를 해버린다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[싱글톤]
객체의 생성을 1개로 제한하고 언제 어디서든 쉽게 접근이 가능한 코어 시스템을 위해서는 extern이 사용될수 있지만 extern이 사용된다는건
어디서든 새롭게 객체의 생성을 또 할수도 있다는것이기에 이것을 방지하기위해 생성자를 private으로 숨겨버리는것이다.
객체 생성할때에는 생성자가 반드시 호출되어야하는데 private으로 설정시 생성자를 다른곳에서 부를 수 없고 자기 파일내에서 본인만 호출이 가능하기 때문이다.
대신 이 경우는 extern선언도 안된다.

대신 public내에서 자신의 생성자를 호출 할 수 있는 함수를 제공하여 그것을 반환하게끔 해준다.
그러나 클래스의 함수는 객체를 생성해야만 쓸 수 있는 구조로 되있기에 함수를 호출 할수가 없다.
그러나 객체가 없어도 되는 함수는 호출 할 수 있다.

static키워드가 붙은 멤버함수는 객체없이 자료형만으로도 호출이 가능하다.
그러나 정적(static)멤버 함수는 일반적인 멤버함수처럼 this 즉 객체를 생성 시킨뒤에 자신의 멤버변수들이 어떤 객체의 멤버변수인지를 알 수가 없다.
멤버변수의 소환 없이 자기 혼자만 호출되었기 떄문이다. 애초에 객체없이 호출이 가능한건 누가 호출했는지 알 필요가 없다 즉 this를 알 필요없다 인 것이다.

또한 객체를 생성해서 호출한다해도 this가 전달 될 수 있는 구조가 아니다.
그러나 접근 가능한 멤버가 있는데 똑같은 정적인경우에 접근이 가능하다

정적멤버와 정적함수는 클래스 내부에서만 접근이 가능하고 그 클래스 내부에 하나만 존재하고 클래스 내부에서끼리 static으로 접근이 가능하기 때문에
하나만 생성된것과 다름이 없다. 클래스를 어디에 선언해도 static은 무조건 하나만 존재하기 때문에 구조상으로 하나만 존재하게 만들어진 것이다.

★또한 클래스내부에 선언된 정적멤버는 클래스 밖에서 초기화를 무조건 해줘야한다.(데이터에 올라갈것이기 때문에)

	static void Release()
	{
		CCore* p = GetInstance();
		delete p;
	}

코어라는 객체를 하나만 만들어서 동적으로 할당해 힙에 할당하였을경우에는 우리가 직접 delete를 시켜줘야한다.
그렇기에 core의 주소를 그대로 반환하는 getinstance를 그대로 받으면 그 주소를 그대로 들고오기 때문에 그대로 delete를 시키면 되지만

만약 내가 다시 getinstance를 받아야된다면, static으로 완성된 코어변수는 삭제된 주소를 그대로 들고 있는것이기 때문에 다른 방안이 필요하다.
지역변수내에서만 코어 변수를 만들게 아니라 이것을 클래스 전체 내에서 쓸 수 있게 만들어주면 해결되는 문제이다.

	static CCore* GetInst()
	{
		static CCore core;

		return &core;
	}

위의 경우는 데이터 영역에 바로 올린 경우이다. 이 경우에는 내가 릴리즈를 신경 쓸 필요는 없지만
내가 원하는 경우에 해제가 불가능하다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[미리 컴파일된 헤더]
프로젝트내에 속성에서 미리컴파일된헤더에서 만들기로 표시해두면 그 아래에 있는 이름대로 헤더파일을 만들어놓고 그 헤더파일은 모든 파일에 들어가야만하는
규칙이 생긴다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[getDC]
beginPaint는 무효화 영역이 감지되는 순간 그리는것을 시작하고 EndPaint로 그리기가 끝났음을 알리는 유기적 연결구조로 되있기에 함부로 이용할 수 없다.
우리는 그림을 그리고만 싶을뿐이기에 getDC를 사용하면되고 getDC는 커널 오브젝트이기 때문에 클래스가 끝날때 ReleaseDC를 해주면 된다.